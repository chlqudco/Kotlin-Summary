
- Kotlin
	- Jetbrain회사에서 만든 언어
	- 제트브레인은 인텔리J를 만듬
	- 인텔리J를 기반으로 만든 프로그램이 안드러이드 스튜디오
		- 안드로이드 스튜디오는 2013년에 나옴
	- 2016 년에 나옴
	- 자바를 보완하기 위해 만든 언어
	- 자바가 동작하는 환경에선 완전한 호환이 됨
	- 2017년도에 코틀린이 공식 언어로 채택됨
	- 결론적으로 편하고 쉽다. 나온지 얼마 안된 언어라서 강하다.

- 기초 문법
	- 세미콜론을 사용하지 않음

- 함수 선언
```
fun sum(a: Int, b: Int): Int{
	return a+b
}
```
- 또는 표현식으로 함수 선언 가능
```
fun sum(a: Int, b: Int) = a+b
fun max(a: Int, b: Int) = if(a>b) a else b
```

- 변수 선언
```
val a: Int = 1
val a = 2 // 타입 추론
```

- 타입
	- 정수형 : Byte, Short, Int, Long
	- 실수형 : Float, Double
	- 그 외: Char, String, Boolean

- 반복문
	- for 반복문
```
for(i in 1..5){} // 1 2 3 4 5 반복
마지막 숫자 포함하기 싫으면 until 로 교체
for(i in 6 downTo 0 step 2) // 6 4 2 0 반복

val numberList = listOf(1,2,3,4)
for(number in numberList)로 객체 반복 가능
```

	- while 반복문
```
while(x>0){}
do while문도 가능
```

- 조건문
```
if(a>b) 어쩌구
코틀린의 if는 표현식으로도 표현 가능
val max = if(a>b){ a } else { b }

when(x) {
	1 -> {}
	2 -> {}
	3 -> {}
	4,5 -> {}
	in 10..20 -> {}
	!in 30..40 -> {}
	is Int -> {}
	else -> {}
	별거 다 가능
}
```

- 자바 VS 코틀린
	- 코틀린은 Null Safe 기능이 있어서 NPE를 방지할 수 있다
	- NPE를 예방하기 위해 널이 되는 타입과 될 수 없는 타입을 나눠놓음
	
- Scope 함수 (범위 함수)
	- apply, with, let, also, run
	- 일시적으로 범위가 생성되며 객체에 자유롭게 접근이 가능해짐
	- apply
		- this로 접근가능 및 this 생략 가능
		- 반환값이 객체 자신이라 보통 초기화에 많이 씀
```
val person = Person().apply{
	firstName = "123"
	lastName = "asd"
}
```

	- also 함수
		- 객체가 파라미터로 전달 됨
		- 파라미터 명 지정 가능 및 지정 안하면 it임

	- let 함수
		- 주로 널이 아닌 객체에서 람다를 실행하기 위해 씀
		- 객체?.let {}
		- 코드 블럭의 수행 결과가 반환됨

	- with 함수
		- 반환값 : 결과값
		- 객체 안에 있는 것들을 this나 생략을 통해 호출 가능
		- 확장 함수로 사용 못함

	- run 함수
		- 객체 초기화와 연산이 필요한 경우에 유용함
		- 반환값 : 결과값

	
- Data Class
	- 데이터 저장을 목적으로 만들어진 클래스
	- 4개의 함수가 자동으로 생성됨

- 람다 표현
	- 코틀린은 간편한 람다 함수를 제공함
	- 버튼 클릭 로직도 자바와 비교했을 때 아주 간소화 됨

- 지연 초기화
	- 나중에 초기화 하고 싶을 때 사용하는 구문
	- 널이 아닌 값이 초기값이 없을 때 나중에 초기화 가능
	- lateinit : var 형식에 사용
	- lazy init : val 형식에 사용
	- 맞나..? 아닌거 같은데


# 너무 단순한 내용은 생략했습니다

- 코틀린 코드를 컴파일하면 자바 컴파일러가 생성하는 것과 동일한 바이트코드가 생성됨
- 서로의 코드 직접 호출하여 사용할 수 있다
- 안드로이드 스튜디오의 Convert to Java File to Kotlin File을 선택하면 변환됨

---
- 데이터 타입
   - 코틀린의 모든 데이터 타입은 객체이다.
   - 따라서 많은 함수와 속성을 제공한다
   - 정적 타입 프로그래밍 언어이므로 한번 선언된 타입의 변수는 다른 타입 데이터를 저장할 수 없음
- 정수형 데이터 타입
   - Byte : 8비트
   - Short : 16비트
   - Int : 32비트
   - Long : 64비트

- 부동 소수점 데이터 타입
   - Double : 64비트
   - Float : 32비트

- Boolean
   - True or False

- 문자 데이터 타입
   - Char : 16비트 유니코드

- 문자열 데이터 타입
   - String은 단어나 문장으로 구성되는 문자열임
   - 여러 문자열 처리 함수가 내장
   - 여러줄로 된 문자열 저장 하기 위해선 """사용

---
- 변수
   - 컴퓨터 메모리에 위치하여 앱에서 사용되는 데이터를 저장하기 위함
- 가변 변수
   - 변수의 값을 변경할 수 있음
   - var

- 불변 변수
   - 값이 한번 저장되면 변경할 수 없음
   - 반복 사용하는 값을 저장할 때 유용
   - val

- 타입 어노테이션
   - var cnt : Int = 10

- 타입 추론
   - 타입을 지정하지 않으면 컴파일러가 알아서 추론함

- Null 가능 타입
   - 대부분의 다른 언어에는 없는 개념
   - 변수가 null값을 가질수 있는 경우에 안전하게 처리하기 위함
   - 기본 변수는 null 불가능 타입이다
   - var name: String? = null

- 안전 호출 연산자
   - 널 가능 타입을 안전하게 호출하기 위해 ?. 를 사용해야 함
   - 널이 아닌 경우에먼 뒤의 함수를 호출함
   - if문을 안써도 되는 편리함이 따라옴

- Not-null assertion
   - 무적건 널이 아니라고 단언
   - !!. 를 사용
   - 디버깅 목적으로 사용하기도 함

- let 함수
   - 널이 아닐 때만 let뒤의 람다식을 실행함

- lateinit
	- 해당 변수가 나중에 초기화 된다는걸 의미함
	- null 불가능 타입 변수를 나중에 초기화 할 수 있다
	- 사용하기 전에 초기화 하는 일은 프로그래머의 책임
	- 초기화 전에 사용하면 당연히 예외 발생
	- 초기화 되었는지 확인은 ::변수이름.isInitialized

- Elvis operator
	- ?:
	- 엘비스 프레슬리 이모티콘과 비슷하다고 해서 붙여진 이름
	- 널이 아니면 왼쪽(본인), 널이면 오른쪽 반환
	- if else를 한줄로 줄일 수 있음

- 타입 변환 (type casting)
	- 원하는 객체 타입을 컴파일러에게 알려주는 작업
	- as 뒤에 원하는 객체 이름 쓰기
	- null 가능한 경우 as? 객체 로 사용
	- 특정 타입인지 확인할 때는 is 키워드 사용

- 흐름 제어 (flow control)
	- 코드의 로직에서는 하나 이상의 조건에 기반하여 실행할 코드와 횟수를 결정 짓는 상황이 있다.
	- 루프 흐름 제어와 조건 흐름 제어가 있다
	- 반복문이랑 조건문임

- 루프 흐름 제어
	- for ~ in
		- 컬렉션이나 숫자 범위 항목을 반복 처리하는데 사용된다
		- 반복 횟수를 아는 경우에 사용
```
for(변수명 in 컬렉션이나 범위){
	// 실행될 코드
}

for(idx in 100 downTo 90){
	//100부터 90까지 반복
}

for(idx in 1 until 10){
	//1부터 9까지 반복
}

```
	- while 반복문
		- 몇번 반복할 지는 모르고 특정 조건을 충족할 때까지 반복
	
	- do while 반복문
		- 일단 한번 실행하고 그 다음에 조건 검사

	- 라벨을 통해 원하는 곳으로 빠져나올 수 있다
		 - 반복문 앞에 라벨을 붙여야 한다
```
outerloop@ for (){
	for (){
		break@outerloop
	}
}
다 빠져나옴
```

- 조건 흐름 제어
	- if 문
	- when 문

- 

---

- 함수
	- 잘 조직되고 효율적인 코드를 작성하는데 필요한 필수 요소
	- 코드의 중복을 줄여줌
	- 특정 작업을 따로 함수로 작성하면 좋다
```
fun 함수이름 (매개변수이름 : 타입, ): 반환타입{
	함수 본문
}
```
	- 함수 본문에 하나의 표현식만 있을 때는 중괄호가 필요 없다.
	- 반환 타입을 컴파일러가 추론할 수 있는 경우는 생략해도 된다
```
fun multiply(x: Int, y: Int) = x * y
```
	- 매개변수에는 기본값을 정의할 수 있다
	- 가변인자 : 인자의 개수를 가변적으로 전달할 수 있다
		- vararg 키워드 사용
		- 하나의 함수에는 하나의 가변인자만 지정할 수 있다.

- 람다식
	- 독립적인 코드 블록이다
```
val multiply = {val1 : Int, val2: Int -> val1 * val2}
```
	- 람다 뒤에 인자를 포함하는 괄호를 추가하면 선언과 동시에 실행됨

```
val multiply = {val1 : Int, val2: Int -> val1 * val2}(10,20)
```
	- 리턴문이 없으므로 맨 마지막에 반환값을 적으면 된다


- 고차 함수
	- 람다식이나 함수의 참조를 인자로 받거나 결과로 반환할 수 있는 함수
	- 말이 어렵다. 걍 함수 매개변수에 함수 적는 행위 임
	- 반환값으로 함수를 반환해도 됨, 진짜 개어려움
```
fun name(매개변수이름: (Int, String) -> Int, value : String){
	val result = 매개변수이름(10,"aaa")
}
```

---

- 객체
	- 클래스 인스턴스라고 하며 독립적인 기능을 갖는 모듈이다
	- 자신의 데이터를 갖는 속성과 메서드로 구성된다

- 클래스
	- 생성되는 객체가 어떤 속성을 가지며 어떤 일을 하는지 정의
```
class 클래스명: 부모클래스명 {
	// 속성 및 함수
}
```

- 생성자
	- 클래스 인스턴스가 생성될 때 초기화 하는 작업
	- 여러 생성자를 가질 수 있다
	- 보조 생성자
```
constructor(name: String){

}
```		
	- 기본 생성자
		- 클래스의 헤더에 선언함
		- 그.. 클래스 안에서 다룰거기 때문에 val이나 var같은 키워드 필요
		- val 안쓰면 해당 함수에서만 쓸수 있다는 뜻인가?
```
class 클래스명(val name: String) {

}
```
- 초기화 블록
	- 기본 생성자 다음에 자동 실행된다
	- 기본 생성자가 없고 보조 생성자만 있으면 실행 안되니 주의
	- 인스턴스가 생성될 때 수행될 초기화 코드를 적어두면 편리

- 커스텀 접근자
	- 속성값에 get() 이나 set()을 구현하는 것
	- 속성값이 반환되거나 설정되기 전에 원하는 로직을 실행할 수 있음

- inner 클래스
	- 외곽 클래스의 속성을 사용할 수 있음
	- inner를 안쓴 중첩 클래스는 사용이 불가능

- companion object
	- 자신을 포함하는 클래스의 모든 인스턴스가 공유하는 속성과 함수를 작성
	- 자바의 static과 비슷
	- 인스턴스를 생성하지 않아도 호출할 수 있음
	- 모든 클래스 인스턴스는 같은 컴패니언 오브젝트를 공유함. 싱글턴임

---
- 상속
	- 부모의 특성을 상속받으면서 나만의 특성을 추가할 수 있음
	- 최상위 클래스 (base class, root class) 는 Any 클래스임
	- 새로 만든 클래스를 자식, 서브 클래스라고 부름
	- 상속받은 클래스를 부모, 슈퍼 클래스라고 부름
	- 다중상속 지원 X
	- 부모 클래스에 open 키워드를 써야 상속 가능
	- 부모가 생성자를 갖는 클래스면 내가 전달해줘야 함
		- 아니 왜 여기선 val 키워드를 안쓰지?
	- 보조 생성자를 만드는것도 하나의 방법임
```
class aaa(name: String): bbb(name){

}

or

클래스 안에
constructor(name: String) : super(name)
```
